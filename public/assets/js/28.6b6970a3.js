(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{461:function(_,v,t){"use strict";t.r(v);var e=t(2),a=Object(e.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h2",{attrs:{id:"发布订阅模式和stream流"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#发布订阅模式和stream流"}},[_._v("#")]),_._v(" 发布订阅模式和Stream流")]),_._v(" "),v("blockquote",[v("p",[_._v("可以创建一个频道，让每个订阅它的客户端都收到消息")])]),_._v(" "),v("h2",{attrs:{id:"_1、发布和订阅"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1、发布和订阅"}},[_._v("#")]),_._v(" 1、发布和订阅")]),_._v(" "),v("p",[v("code",[_._v("PUBLISH channel message")]),_._v(" "),v("strong",[_._v("发布消息")]),_._v("，")]),_._v(" "),v("p",[v("code",[_._v("SUBSCRIBE channel[channel ...]")]),_._v(" "),v("strong",[_._v("订阅频道")])]),_._v(" "),v("p",[_._v("channel是频道的名称")]),_._v(" "),v("p",[_._v("先发起订阅，"),v("strong",[_._v("如果不存在频道则创建频道并订阅")])]),_._v(" "),v("p",[_._v("发布订阅还有一些局限性，无法消息持久化，无法记录历史消息，可以通过Stream流来解决这些问题。")]),_._v(" "),v("h2",{attrs:{id:"_2、stream流"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2、stream流"}},[_._v("#")]),_._v(" 2、Stream流")]),_._v(" "),v("blockquote",[v("p",[_._v("redis5.0当中引入的数据结构，是一个轻量级的消息队列，可以解决数据持久化问题")])]),_._v(" "),v("h3",{attrs:{id:"_2-1-添加消息"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-添加消息"}},[_._v("#")]),_._v(" 2.1 添加消息")]),_._v(" "),v("p",[v("code",[_._v("XADD key id field value [field value ...]")]),v("strong",[_._v("星号代替id表示让redis自动生成消息id")]),_._v("，能传入任意个键值对")]),_._v(" "),v("p",[_._v("id格式 "),v("code",[_._v("整数-整数")]),_._v("第一个是时间戳，第二个是序列号，自己传入id要保证id是递增的")]),_._v(" "),v("h4",{attrs:{id:"_2-1-1-创建组"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-1-创建组"}},[_._v("#")]),_._v(" 2.1.1 创建组")]),_._v(" "),v("p",[v("code",[_._v("XGROUP create 消息队列 组名称 id")])]),_._v(" "),v("p",[_._v("创建一个消费者组")]),_._v(" "),v("p",[v("code",[_._v("XGROUP create 消息队列 组名称 id")])]),_._v(" "),v("p",[v("code",[_._v("XINFO GROUPS 组名称")]),_._v(" 获取组信息")]),_._v(" "),v("p",[_._v("添加消费者:")]),_._v(" "),v("p",[v("code",[_._v("XGROUP CREATECONSUMER 消息队列 组名 消费者名")])]),_._v(" "),v("p",[_._v("使用消费者读取消息:")]),_._v(" "),v("p",[v("code",[_._v("XREADGROUP GROUP 组名 消费者名 [COUNT count] BLOCK 3000 STREAM 消息队列名")])]),_._v(" "),v("h3",{attrs:{id:"_2-2-查看流信息"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-查看流信息"}},[_._v("#")]),_._v(" 2.2 查看流信息")]),_._v(" "),v("p",[v("code",[_._v("XLEN key")]),_._v(" 查看消息队列长度")]),_._v(" "),v("p",[v("code",[_._v("XRANGE key strat stop [count]")]),_._v("查看消息队列具体信息 用"),v("code",[_._v("-")]),_._v("和"),v("code",[_._v("+")]),_._v("代替start和stop")]),_._v(" "),v("h4",{attrs:{id:"_2-2-1-读取消息"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-1-读取消息"}},[_._v("#")]),_._v(" 2.2.1 读取消息")]),_._v(" "),v("p",[v("code",[_._v("XREAD [COUNT count]")]),_._v("  例如 "),v("code",[_._v("XREAD key COUNT 2")]),_._v("  表示读取两条消息")]),_._v(" "),v("p",[v("code",[_._v("XREAD [COUNT count] BLOCK 1000 STREAM 消息队列名 0")]),_._v("   表示如果为空则"),v("strong",[_._v("阻塞1000毫秒，也就是等待一秒")]),_._v("，期间收到消息就能获取到，")]),_._v(" "),v("p",[_._v("然后读取指定消息队列的消息,"),v("strong",[_._v("0表示从0开始读取")]),_._v("，如果希望获取从现在以后的最新消息，可以换成$，建议设置堵塞事件长一点，因为接受消息是在堵塞时间内的新消息。")]),_._v(" "),v("p",[_._v("条数通过[COUNT count]控制")]),_._v(" "),v("h3",{attrs:{id:"_2-3-删除消息"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-删除消息"}},[_._v("#")]),_._v(" 2.3 删除消息")]),_._v(" "),v("p",[v("code",[_._v("XDEL key id [id... ]")]),_._v("通过id删除")]),_._v(" "),v("p",[v("code",[_._v("XTRIM key MAXLEN 0")]),_._v(" 删除所有消息")])])}),[],!1,null,null,null);v.default=a.exports}}]);